import geometricNetwork as ge_net
import Point as pnt
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

# -----------------------------------------------------------------------------------------------------------
# Divide the unit cube into sectors depends on the value of r

def divide_to_grid(net, n, r):
    num_of_groups = int(np.floor((2 / r) ** 2))
    num_of_one_side = int(np.floor((2 / r)))
    arr_of_nodes = np.array(net.nodes)

    # Unable to use np.array due to different length of sub groups
    groups_on_grid = []

    # Divide the nodes to groups by their coordinates
    # Double loop, doesnt depend on the size of the input n but rather on r which is a small value
    # Does not affect the linearity of the algorithm
    i = 0
    for x in range(num_of_one_side):
        for y in range(num_of_one_side):
            arr = subgroup_by_condition(arr_of_nodes, x * (r / 2), (x + 1) * (r / 2), y * (r / 2), (y + 1) * (r / 2))
            dict_square = {'i': i, 'arr_points': arr, 'bnd_x_down': x * (r / 2), 'bnd_x_up': (x + 1) * (r / 2),
                           'bnd_y_down': y * (r / 2), 'bnd_y_up': (y + 1) * (r / 2), 'degree': len(arr),
                           'index_graph': -1, 'is_den': is_dense(arr, n, r)}
            groups_on_grid.append(dict_square)
            #groups.append(arr)
            i += 1
    #print_squares_arr(groups)
    return groups_on_grid #list od dictionary


# -----------------------------------------------------------------------------------------------------------
# Calculate the threshold between sparse and dense

def calculate_threshold(n, r):
    num_of_groups = int(np.floor((2 / r) ** 2))
    return int(np.floor(n / (num_of_groups * 2)))


# -----------------------------------------------------------------------------------------------------------
# Return np.array after filtering the points, only points within the current sector will be inside

def subgroup_by_condition(arr_of_nodes, bnd_x_down, bnd_x_up, bnd_y_down, bnd_y_up):
    """subgrp_lst = []
        for i in range(0, len(group)):
            if group[i].x_value >= bnd_x_down and group[i].x_value < bnd_x_up and group[i].y_value >= bnd_y_down and group[i].y_value < bnd_y_up:
                subgrp_lst.append(group[i])
        return np.array(subgrp_lst)"""
    return np.array(list(filter(
        lambda p: bnd_x_down <= p.x_value < bnd_x_up and bnd_y_down <= p.y_value < bnd_y_up,
        arr_of_nodes)))

# -----------------------------------------------------------------------------------------------------------
# Get arr_nodes and check if dense

def is_dense(arr_points, n, r):
    threshold = calculate_threshold(n, r)
    if len(arr_points) > threshold:
        return True
    return False

# -----------------------------------------------------------------------------------------------------------
# Divide groups_on_grid to sparse and dense

def divide_dense_from_sparse(groups_on_grid):
    dense_group = []
    sparse_group = []
    for i in range(len(groups_on_grid)):
        if groups_on_grid[i]['is_den']:
            dense_group.append(groups_on_grid[i])
        else:
            sparse_group.append(groups_on_grid[i])
    return dense_group, sparse_group #lists of dictionaries

# -----------------------------------------------------------------------------------------------------------
# Connect between every point in a sparse square to a dense square

def label_sparse_point_to_dense(net, groups_on_grid, dense_group, sparse_group, r):  # To match to a square or to a point??
    # ???
    '''sparse_point_list = []
    for sparse_square in sparse_group:
        for p in sparse_square:
            sparse_point_list.append(p)'''
    #for p in sparse_point_list:

    '''
    For i in range (-2, 3)#without himself
      For j in range (-2, 3)
    1)In dense squares if boundaries x = i*myboundry  and y = j*myboundry insert to my friends 
    2)For every point in me try to match a point that is connected to me (do not go through all point in it)
    '''

    # Dictionary that contains lists of dense friends of each sparse square
    friends_dict = {}
    for sparse_index, sparse_square in enumerate(sparse_group):
        # For each sparse square get his friends(at most 24)
        curr_friends = []
        for dense_square in dense_group:
            if is_friend(sparse_square, dense_square, r) == True:
                curr_friends.append(dense_square)  # curr_friends can be empty - if the square is empty
        print("The list of friends of i =", sparse_square['i'], "is :")
        print_list_of_dict(curr_friends)
        friends_dict[str(sparse_square['i'])] = curr_friends
        print("#####################################################")
    ''' for sparse_index, sparse_square in enumerate(sparse_group):
        # For each sparse square get his friends(at most 24)
        curr_friends = []
        for dense_index, dense_square in enumerate(dense_group):
            if is_friend(sparse_square, dense_square, r) == True:
                curr_friends.append(dense_square) # curr_friends can be empty - if the square is empty
        print("The list of friends of i =", sparse_square['i'], "is :")
        print_list_of_dict(curr_friends)
        friends_dict[str(sparse_index)] = curr_friends
        print("#####################################################")'''
    # filtered_list = list(filter(lambda dense_square: is_friend(sparse_square, dense_square), dense_group))
    # print("The list of friends of i =",index, "is :" ,filtered_list)



    # Initialize data structures : dictionary by the length of the sparse group
    # For each sparse there will be a dictionary for all its vertices
    # For each vertex there will be a list containing two vertices connecting to this vertex by the greedy algorithm
    # The efficiency is linear because the length of the sparse square is very low
    # In addition, the sum of the lengths of each dictionary is the number of nodes in g_tag

    '''dict_labels = {}
    for curr_square in sparse_group:
        dict_square = {}
        serial_str_sq = str(curr_square['i'])
        for p in curr_square['arr_points']:
            serial_str_point = str(p.serial_number)
            dict_square[serial_str_point] = build_pair(net, p, friends_dict[serial_str_sq], curr_square['degree'])
        dict_labels[serial_str_sq] = dict_square


    # Run all over the sparse squares and insert an edge to g_tag between the square and its friend if they are connected
    for k in friends_dict.keys():
        num_of_sparse = int(k)
        list_of_sparse_sq = friends_dict[k]'''

    return friends_dict
# -----------------------------------------------------------------------------------------------------------
# Build g'

def build_g_tag(net, dense_group, threshold):
    '''
     dict_square = {'i': i, 'arr_points': arr, 'bnd_x_down': x * (r / 2), 'bnd_x_up': (x + 1) * (r / 2),
                           'bnd_y_down': y * (r / 2), 'bnd_y_up': (y + 1) * (r / 2), 'degree': len(arr),
                           'index_graph': -1, 'is_den': is_dense(arr, n, r)}
    '''
    g_tag = nx.Graph()
    # Add vertices to the g_tag
    counter = 0
    for sq in dense_group:
        if sq['degree'] != 0:
            pos_x = (0.5)*(sq['bnd_x_down'] + sq['bnd_x_up'])
            pos_y = (0.5) * (sq['bnd_y_down'] + sq['bnd_y_up'])
            g_tag.add_node(counter, pos=(pos_x, pos_y))
            sq['index_graph'] = counter
            counter += 1
            print("g_tag point number:", sq['index_graph'], "number of square:", sq['i'], "degree:", sq['degree'])

    # Run all over groups_on_grid in 2 loops
    # If they both sparse -> continue (we dont want to connect sparse square to each other)
    # Else : check if there is an edge between the two groups -> add edge between the squares to g_tag
    for sq1 in dense_group:
        for sq2 in dense_group:
            if sq1 != sq2 and g_tag.has_edge(sq2['index_graph'], sq1['index_graph'])==False and are_squares_connected(net, sq1, sq2):
            # if sq1 != sq2 and are_squares_connected(net, sq1, sq2):
                g_tag.add_edge(sq1['index_graph'], sq2['index_graph'], weight=sq1['degree']+sq2['degree'])
                print("Weight of (", sq1['index_graph'], ",", sq2['index_graph'], ") is :", sq1['degree']+sq2['degree'])
    return g_tag

'''def build_g_tag(net, groups_on_grid, threshold):
    g_tag = nx.Graph()
    # Add vertices to the g_tag
    counter = 0
    for sq in groups_on_grid:
        if sq['degree'] != 0:
            g_tag.add_node(counter)
            sq['index_graph'] = counter
            counter += 1
            print("g_tag point number:", sq['index_graph'], "number of square:", sq['i'])
    # Run all over groups_on_grid in 2 loops
    # If they both sparse -> continue (we dont want to connect sparse square to each other)
    # Else : check if there is an edge between the two groups -> add edge between the squares to g_tag
    for sq1 in groups_on_grid:
        for sq2 in groups_on_grid:
            if sq1['degree'] <= threshold and sq2['degree'] <= threshold:
                continue
            if are_squares_connected(net, sq1, sq2):
                g_tag.add_edge(sq1['index_graph'], sq2['index_graph'])
    return g_tag'''

# -----------------------------------------------------------------------------------------------------------
# Get two squares and return point 1 in square 1 connected to point 2 in square 2

def points_connect_between_squares(net, sq1, sq2):
    for p1 in sq1['arr_points']:
        for p2 in sq2['arr_points']:
            if net.is_at_edge_by_points(net.edges, p1.serial_number, p2.serial_number) == True:
                return p1.serial_number, p2.serial_number
    return -1, -1

# -----------------------------------------------------------------------------------------------------------
# Get two squares and return true if its connected

def are_squares_connected(net, sq1, sq2):
    for p1 in sq1['arr_points']:
        for p2 in sq2['arr_points']:
            if net.is_at_edge_by_points(net.edges, p1.serial_number, p2.serial_number) == True:
                return True
    return False

# -----------------------------------------------------------------------------------------------------------
# Get a network, a point and list containing the friends of the square p where p is
# Return a list of flag two points assign to the current point

def build_pair(net, p, list_of_friends, curr_degree):
    in_out_list = []
    flag = 0
    for sq in list_of_friends:
        for point in sq['arr_points']:
            if net.is_at_edge_by_points(net.edges, point.serial_number, p.serial_number) == True:
                square_point_list = []
                square_point_list.append(sq)
                square_point_list(point)
                sq['degree'] -= 1
                in_out_list.append(square_point_list)
                if curr_degree == 1:
                    if flag == 1:
                        return in_out_list
                    flag = 1
                    continue
                else:
                    return in_out_list
    return in_out_list

# -----------------------------------------------------------------------------------------------------------
# Get group and index and return the square of its index

def find_square_by_point(groups_on_grid, index):
    if index < 0 or index >= len(groups_on_grid):
        return np.nan
    for sq in groups_on_grid:
        if sq['index_graph'] == index:
            return sq
    return np.nan


# -----------------------------------------------------------------------------------------------------------
# Return if the squares are friends

def is_friend(sparse_square, dense_square, r):
    for i in range(-2, 3):
        for j in range(-2, 3):
            '''print("&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%")
            print("dense_square['bnd_x_down'] :", dense_square['bnd_x_down'])
            print("sparse_square['bnd_x_down'] + i*(r/2) :", sparse_square['bnd_x_down'] + i*(r/2))
            print("dense_square['bnd_x_up'] :", dense_square['bnd_x_up'])
            print("sparse_square['bnd_x_up'] + i*(r/2) :", sparse_square['bnd_x_up'] + i*(r/2))
            print("dense_square['bnd_y_down'] :", dense_square['bnd_y_down'])
            print("sparse_square['bnd_y_down'] + i*(r/2) :", sparse_square['bnd_y_down'] + i*(r/2))
            print("dense_square['bnd_y_up'] :", dense_square['bnd_y_up'])
            print("sparse_square['bnd_y_up'] + i*(r/2) :", sparse_square['bnd_y_up'] + i*(r/2))'''
            if dense_square['bnd_x_down'] == sparse_square['bnd_x_down'] + i*(r/2) and dense_square['bnd_x_up'] == sparse_square['bnd_x_up'] + i*(r/2):
                if dense_square['bnd_y_down'] == sparse_square['bnd_y_down'] + j*(r/2) and dense_square['bnd_y_up'] == sparse_square['bnd_y_up'] + j*(r/2):
                    return True
    return False
